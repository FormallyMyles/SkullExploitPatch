package us.myles.sep;

import com.comphenix.protocol.ProtocolLibrary;
import com.comphenix.protocol.reflect.FieldAccessException;
import com.comphenix.protocol.wrappers.nbt.NbtBase;
import com.comphenix.protocol.wrappers.nbt.NbtCompound;
import com.comphenix.protocol.wrappers.nbt.NbtFactory;
import com.comphenix.protocol.wrappers.nbt.NbtList;
import com.google.common.io.BaseEncoding;
import org.bukkit.Bukkit;
import org.bukkit.Chunk;
import org.bukkit.Material;
import org.bukkit.block.Block;
import org.bukkit.block.BlockState;
import org.bukkit.entity.Entity;
import org.bukkit.entity.Item;
import org.bukkit.inventory.ItemStack;
import org.bukkit.plugin.java.JavaPlugin;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class SkullExploitPatch extends JavaPlugin {
    public void onEnable() {
        // Packet Listener
        ProtocolLibrary.getProtocolManager().addPacketListener(new SkullExploitListener(this));
        // Chunk Load Listener
        Bukkit.getPluginManager().registerEvents(new ChunkPatcher(this), this);
        // Item Listener
        Bukkit.getPluginManager().registerEvents(new ItemPatcher(this), this);
    }

    public boolean isExploit(ItemStack stack) {
        try {
            if (stack == null) {
                return false;
            }
            if (stack.getType() == Material.SKULL || stack.getType() == Material.SKULL_ITEM) {
                // Check human
                if (stack.getDurability() == 3) {
                    NbtCompound tag = (NbtCompound) NbtFactory.fromItemTag(stack);
                    if (isExploit(tag)) {
                        return true;
                    }
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
            //nbt read error
        }
        return false;
    }

    @SuppressWarnings("rawtypes")
    public boolean isExploit(NbtCompound root) {
        String ownerTag;
        if (root.containsKey("SkullOwner")) {
            ownerTag = "SkullOwner"; // item
        } else if (root.containsKey("Owner")) {
            ownerTag = "Owner"; // block
        } else {
            return false; // neither ==> not an exploit
        }
        NbtCompound skullOwner = root.getCompound(ownerTag);
        if (skullOwner.containsKey("Properties")) {
            NbtCompound properties = skullOwner.getCompound("Properties");
            if (properties.containsKey("textures")) {
                NbtList<NbtBase> textures;
                try {
                    textures = properties.getList("textures");
                } catch (FieldAccessException e) {
                    // incorrect formatting causing a FAE can be used to bypass SkullExploitPatch.
                    // example: not including the first byte at the beginning of the NBT list which signifies type
                    // yields (FieldAccessException: No field with type byte exists in class NBTTagList.)
                    // This might be somewhat of a "jank" solution, but as far as I know it is the only one without
                    // directly patching ProtocolLib. Even doing toString() or getValue("textures") will result in
                    // the same exception when this particular exploit is used.
                    return true;
                }
                for (NbtBase texture : textures.asCollection()) {
                    if (texture instanceof NbtCompound) {
                        // Check for value
                        if (((NbtCompound) texture).containsKey("Value")) {
                            if (((NbtCompound) texture).getString("Value").trim().length() > 0) {
                                // Check json
                                try {
                                    String decoded = new String(BaseEncoding.base64().decode(((NbtCompound) texture).getString("Value")));
                                    JSONObject object = (JSONObject) new JSONParser().parse(decoded);
                                    if (object.containsKey("textures")) {
                                        object = (JSONObject) object.get("textures");
                                    }
                                    if (object.containsKey("SKIN")) {
                                        object = (JSONObject) object.get("SKIN");
                                    }
                                    if (!object.containsKey("url")) {
                                        root.remove(ownerTag);
                                        return true;
                                    }
                                    if (((String) object.get("url")).trim().length() == 0) {
                                        root.remove(ownerTag);
                                        return true;
                                    }
                                    return false;
                                } catch (Exception e) {
                                    // Decode failed
                                    root.remove(ownerTag);
                                    return true;
                                }
                            } else {
                                root.remove(ownerTag);
                                return true;
                            }
                        } else {
                            root.remove(ownerTag);
                            return true;
                        }
                    }
                }
            }
        }
        return false;
    }

    public void cleanChunk(Chunk chunk) {
        // Clean blocks
        List<Block> heads = new ArrayList<>();

        for (BlockState state : chunk.getTileEntities()) {
            // Check for skull
            if (state != null && (state.getType() == Material.SKULL || state.getType() == Material.SKULL_ITEM)) {
                // Check human
                heads.add(state.getBlock());
            }
        }

        for (Block head : heads) {
            try {
                //Dont skip loop if error
                NbtCompound root = NbtFactory.readBlockState(head);
                if (isExploit(root)) {
                    getLogger().warning("Removing exploit block, " + head.getLocation());
                    head.setType(Material.AIR);
                }
            } catch (Exception e) {
                // Failed to read chunk data, probably odd version and need to update protocol lib.
            }
        }

        // Clean entities
        for (Entity e : Arrays.asList(chunk.getEntities())) {
            if (e instanceof Item) {
                Item item = (Item) e;
                if (isExploit(item.getItemStack())) {
                    item.remove();
                    getLogger().warning("Removing exploit item entity, " + item.getLocation());
                }
            }
        }
    }
}
